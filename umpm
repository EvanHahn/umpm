#! /usr/bin/env python2

import os
import sys
import json
import shutil
import errno
import tarfile
import hashlib
from urllib import urlretrieve
from glob import iglob

path = {}
path['main'] = '~/.umpm'
path['sources'] = '~/.umpm/sources'
path['bin'] = '~/.umpm/bin'
path['man'] = '~/.umpm/man'
path['tmp'] = '~/.umpm/tmp'
path['lib'] = '~/.umpm/lib'
path['blue'] = '~/.umpm/blue'
for key in path:
    path[key] = os.path.expanduser(path[key])

# --- utility functions ---

def source_paths():
    return iglob(path['sources'] + '/*')

def bin_path_for(package_name):
    info = package_info_for(package_name)
    package = package_name
    if u'bin' in info:
        package = info[u'bin']
    return os.path.join(path['bin'], package)

def blue_path_for(package_name):
    return os.path.join(path['blue'], package_name)

def source_path_for(desired_package):
    for source in source_paths():
        source_name = os.path.basename(source)
        packages = iglob(path['sources'] + '/' + source_name + '/packages/*')
        for package in packages:
            package_name = os.path.basename(package)
            if package_name == desired_package:
                return package
    return None

def cloned_path_for(package, version=None):
    return os.path.join(path['blue'], package + '/' + version)

def package_source_file(package, filename):
    directory = source_path_for(package)
    if directory is None:
        return None
    return os.path.join(directory, filename)

def package_info_for(package):
    data_path = package_source_file(package, 'package.json')
    if data_path is None:
        return None
    data_file = open(data_path)
    data = json.load(data_file)
    data_file.close()
    return data

def run_package_command(package, version, command):
    result = -1
    original_path = package_source_file(package, command)
    cloned_path = cloned_path_for(package, version)
    with open(original_path, 'r') as original:
        compiled_path = os.path.join(cloned_path, 'temp-umpm-compiled')
        compiled_contents = original.read().format(
            PREFIX=path['main'],
            LIB=path['lib']
        )
        with open(compiled_path, 'w') as compiled_file:
            compiled_file.write(compiled_contents)
        command = 'chmod 775 ' + compiled_path + ' && ('
        command += 'cd ' + cloned_path + ' && '
        command += 'exec ' + compiled_path + ')'
        result = os.system(command)
        os.remove(compiled_path)
    return result

def sha1_of(path):
    with open(path, 'rb') as file:
        return hashlib.sha1(file.read()).hexdigest()

# --- unknown command ---

def unknown(argv):
    print 'Unknown command. The heck?'
    exit(errno.EINVAL)

# --- help command ---

def help(argv):
    print 'Usage:'
    print
    print '    umpm install package_name'
    print '    umpm search search'

# -- uninstall umpm command --

def uninstall_umpm(argv):

    print "Are you sure you want to uninstall me? This won't uninstall all of your packages."
    it_is = raw_input('Type "for sure" to uninstall: ')
    print
    if it_is == 'for sure':
        shutil.rmtree(path['main'])
        print 'umpm uninstalled. Make sure to remove umpm from your $PATH.'
        print
        print 'Goodbye!'
    else:
        print 'Aborting uninstall. I live another day.'

# --- uninstall command ---

def uninstall(argv):

    if len(argv) < 1:
        print 'What package do you want to uninstall?'
        exit(errno.EINVAL)

    package_name = argv[0]

    info = package_info_for(package_name)
    version = info[u'version']

    uninstall_path = package_source_file(package_name, 'uninstall')
    if os.path.exists(uninstall_path):
        run_package_command(package_name, version, 'uninstall')

    try: os.remove(bin_path_for(package_name))
    except: pass

    try: shutil.rmtree(cloned_path_for(package_name, version))
    except: pass

    print package_name + ' uninstalled, my friend.'
    post_path = package_source_file(package_name, 'postuninstall.txt')
    if os.path.exists(post_path):
        print
        with open(post_path, 'r') as f:
            print f.read()

# --- install command ---

def install(argv):

    if len(argv) < 1:
        print 'What package do you want to install?'
        exit(1)

    desired_package = argv[0]

    data = package_info_for(desired_package)
    version = data[u'version']
    if data is None:
        print desired_package + ' not found!'
        print 'Try `umpm update` if you think it should be there.'

    package_path = blue_path_for(desired_package)
    if not os.path.isdir(package_path):
        os.mkdir(package_path)
    prefix = os.path.join(package_path, version)

    if os.path.isdir(prefix):
        if '--force' in argv:
            shutil.rmtree(prefix)
        elif '--try' in argv:
            return
        else:
            print desired_package + ' appears to already be installed. Try uninstalling, or:'
            print
            print '    umpm install ' + desired_package + ' --force'
            exit(errno.EEXIST)

    if u'dependencies' in data:
        print 'Installing dependencies...'
        for dependency in data[u'dependencies']:
            if '--force' in argv:
                install([dependency, '--try', '--force'])
            else:
                install([dependency, '--try'])
        print 'Finished installing dependencies.'

    install_path = os.path.join(source_path_for(desired_package), 'install')

    download_type = data[u'download'][u'type']
    download_url = data[u'download'][u'url']

    if download_type == 'curl':

        print 'Downloading ' + desired_package + ' from ' + download_url + '...'

        zip_path = os.path.join(path['tmp'], desired_package + '-temp')
        urlretrieve(download_url, zip_path)

        expected_sha1 = data[u'download'][u'sha1']
        actual_sha1 = sha1_of(zip_path)
        if expected_sha1 != actual_sha1:
            print "Checksum of downloaded file doesn't match! Aborting!"
            print 'SOMEONE COULD BE MESSING WITH YOUR CONNECTION.'
            print
            print '...or maybe there was a download error.'
            exit(errno.EBADE)

        if download_url[-7:] == '.tar.gz':
            print 'Extracting tar.gz file...'
            tar = tarfile.open(zip_path, 'r:gz')
            tar.extractall(prefix)
            tar.close()

        elif download_url[-8:] == '.tar.bz2':
            print 'Extracting tar.bz2 file...'
            tar = tarfile.open(zip_path, 'r:bz2')
            tar.extractall(prefix)
            tar.close()

        else:
            print 'Cannot parse downloaded file. This is probably not your fault.'
            exit(errno.ENOPKG)

    elif download_type == 'git':
        print 'Cloning ' + desired_package + ' from ' + download_url + '...'
        git_command = 'git clone -q ' + download_url + ' ' + prefix
        os.system(git_command)

    elif download_type == 'hg':
        print 'Cloning ' + desired_package + ' from ' + download_url + '...'
        flags = ''
        if u'flags' in data[u'download']:
            flags = data[u'download'][u'flags']
        git_command = '~/.umpm/bin/hg clone ' + flags + ' ' + download_url + ' ' + prefix
        os.system(git_command)

    else:
        print 'Unsupported download type. Probably not your fault.'
        exit(errno.ENOPKG)

    print 'Installing...'
    value = run_package_command(desired_package, version, 'install')

    if value != 0:
        print
        print 'Package install failed with error code ' + str(value) + '.'
        exit(errno.ENOPKG)

    print
    print desired_package + ' installed!'

    post_install_path = package_source_file(desired_package, 'postinstall.txt')
    if os.path.exists(post_install_path):
        print
        with open(post_install_path, 'r') as f:
            print f.read()

# --- the main ---

if __name__ == '__main__':

    argv = sys.argv
    argc = len(argv)

    command = 'help'
    argv_rest = argv[2:]
    if argc > 1:
        command = argv[1]

    {
        'help': help,
        'uninstall': uninstall,
        'install': install,
        'implode': uninstall_umpm
    }.get(command, unknown)(argv_rest)
