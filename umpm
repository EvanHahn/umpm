#! /usr/bin/env python2

import os
import sys
import json
import shutil
import errno
import tarfile
import hashlib
from urllib import urlretrieve
from glob import iglob

path = {}
path['main'] = '~/.umpm'
path['sources'] = '~/.umpm/sources'
path['bin'] = '~/.umpm/bin'
path['man'] = '~/.umpm/man'
path['tmp'] = '~/.umpm/tmp'
path['blue'] = '~/.umpm/blue'
for key in path:
    path[key] = os.path.expanduser(path[key])

# --- utility functions ---

def source_paths():
    return iglob(path['sources'] + '/*')

def blue_path_for(package_name):
    return os.path.join(path['blue'], package_name)

def source_path_for(desired_package):
    for source in source_paths():
        source_name = os.path.basename(source)
        packages = iglob(path['sources'] + '/' + source_name + '/packages/*')
        for package in packages:
            package_name = os.path.basename(package)
            if package_name == desired_package:
                return package
    return None

def cloned_path_for(package, version):
    return os.path.join(path['blue'], package + '/' + version)

def package_source_file(package, filename):
    directory = source_path_for(package)
    if directory is None:
        return None
    return os.path.join(directory, filename)

def package_info_for(package):
    data_path = package_source_file(package, 'package.json')
    if data_path is None:
        return None
    data_file = open(data_path)
    data = json.load(data_file)
    data_file.close()
    return data

def run_package_command(package, version, command):
    original_path = package_source_file(package, command)
    cloned_path = cloned_path_for(package, version)
    with open(original_path, 'r') as original:
        compiled_path = os.path.join(cloned_path, 'temp-umpm-compiled')
        compiled_contents = original.read().format(
            PREFIX=path['main']
        )
        with open(compiled_path, 'w') as compiled_file:
            compiled_file.write(compiled_contents)
        command = 'chmod 775 ' + compiled_path + ' && ('
        command += 'cd ' + cloned_path + ' && '
        command += 'exec ' + compiled_path + ')'
        os.system(command)
        os.remove(compiled_path)

def sha1_of(path):
    with open(path, 'rb') as file:
        return hashlib.sha1(file.read()).hexdigest()

# --- unknown command ---

def unknown(argv):
    print 'Unknown command. The heck?'
    exit(errno.EINVAL)

# --- help command ---

def help(argv):
    print 'Usage:'
    print
    print '    umpm install package_name'
    print '    umpm search search'

# -- uninstall umpm command --

def uninstall_umpm(argv):

    print 'Are you sure you want to uninstall me?'
    it_is = raw_input('Type "for sure" to uninstall: ')
    print
    if it_is == 'for sure':
        shutil.rmtree(path['main'])
        print 'umpm uninstalled. Make sure to remove umpm from your $PATH.'
        print
        print 'Goodbye!'
    else:
        print 'Aborting uninstall. I live another day.'

# --- uninstall command ---

def uninstall(argv):

    if len(argv) < 1:
        print 'What package do you want to uninstall?'
        exit(errno.EINVAL)

    package_name = argv[0]

    # TODO

# --- install command ---

def install(argv):

    if len(argv) < 1:
        print 'What package do you want to install?'
        exit(1)

    desired_package = argv[0]

    data = package_info_for(desired_package)
    if data is None:
        print desired_package + ' not found!'
        print 'Try `umpm update` if you think it should be there.'

    else:

        install_path = os.path.join(source_path_for(desired_package), 'install')

        version = data[u'version']
        package_path = blue_path_for(desired_package)
        if not os.path.isdir(package_path):
            os.mkdir(package_path)
        prefix = os.path.join(package_path, version)

        if os.path.isdir(prefix):
            if '--force' in argv:
                shutil.rmtree(prefix)
            else:
                print desired_package + ' appears to already be installed. Try uninstalling, or:'
                print
                print '    umpm install ' + desired_package + ' --force'
                exit(errno.EEXIST)

        download_type = data[u'download'][u'type']
        download_url = data[u'download'][u'url']

        if download_type == 'curl':

            print 'Downloading ' + desired_package + ' from ' + download_url + '...'

            zip_path = os.path.join(path['tmp'], desired_package + '-temp')
            urlretrieve(download_url, zip_path)

            expected_sha1 = data[u'download'][u'sha1']
            actual_sha1 = sha1_of(zip_path)
            if expected_sha1 != actual_sha1:
                print "Checksum of downloaded file doesn't match! Aborting!"
                print 'SOMEONE COULD BE MESSING WITH YOUR CONNECTION.'
                print
                print '...or maybe there was a download error.'
                exit(errno.EBADE)

            if download_url[-7:] == '.tar.gz':
                print 'Extracting file...'
                tar = tarfile.open(zip_path, 'r:gz')
                tar.extractall(prefix)
                tar.close()

            else:
                print 'Cannot parse downloaded file. This is probably not your fault.'
                exit(errno.ENOPKG)

            exit(1) # TEMP TODO

        elif download_type == 'git':
            print 'Cloning ' + desired_package + ' from ' + download_url + '...'
            git_command = 'git clone -q ' + download_url + ' ' + prefix
            os.system(git_command)

        print 'Installing...'
        run_package_command(desired_package, version, 'install')

        print
        print desired_package + ' installed!'

        post_install_path = package_source_file(desired_package, 'postinstall.txt')
        if os.path.exists(post_install_path):
            print
            with open(post_install_path, 'r') as f:
                print f.read()

# --- the main ---

if __name__ == '__main__':

    argv = sys.argv
    argc = len(argv)

    command = 'help'
    argv_rest = argv[2:]
    if argc > 1:
        command = argv[1]

    {
        'help': help,
        'uninstall': uninstall,
        'install': install,
        'implode': uninstall_umpm
    }.get(command, unknown)(argv_rest)
